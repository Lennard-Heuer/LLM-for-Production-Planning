LP Model Optimization:

previous_solution = """```python
from pulp import LpMaximize, LpProblem, LpVariable, lpSum

# Define the function
def optimize_production():
    # Input data
    time_horizon = 6
    products_total = 4
    workstations_total = 4
    ressources_total = 4

    profit = [132.0, 813.0, 225.0, 131.0]
    holding_costs = [13.0, 18.0, 15.0, 13.0]

    min_sales = [
        [71.0, 28.0, 110.0, 78.0, 45.0, 90.0],
        [5.0, 21.0, 3.0, 211.0, 55.0, 9.0],
        [23.0, 105.0, 27.0, 75.0, 95.0, 43.0],
        [20.0, 36.0, 9.0, 29.0, 30.0, 20.0],
    ]

    max_demand = [
        [371.0, 228.0, 111.0, 478.0, 245.0, 190.0],
        [425.0, 221.0, 381.0, 211.0, 155.0, 90.0],
        [203.0, 415.0, 217.0, 475.0, 95.0, 143.0],
        [200.0, 316.0, 479.0, 259.0, 130.0, 203.0],
    ]

    capacity = [
        [3071.0, 228.0, 1011.0, 4708.0, 2405.0, 1000.0],
        [4205.0, 2201.0, 381.0, 2101.0, 105.0, 900.0],
        [203.0, 405.0, 2107.0, 4075.0, 905.0, 1403.0],
        [200.0, 3016.0, 4709.0, 2059.0, 130.0, 2003.0],
    ]

    production_time = [
        [1.0, 2.0, 1.0, 4.0, 2.0, 9.0],
        [2.0, 1.0, 3.0, 1.0, 5.0, 9.0],
        [2.0, 1.0, 2.0, 4.0, 5.0, 1.0],
        [2.0, 6.0, 4.0, 2.0, 1.0, 2.0],
    ]

    initial_inventory = [41.0, 58.0, 31.0, 38.0]
    yield_loss = [
        [0.9, 0.7, 0.9, 0.8],
        [0.8, 0.6, 0.95, 0.8],
        [0.9, 0.75, 0.9, 0.78],
        [0.95, 0.87, 0.97, 0.98],
    ]
    capacity_reduction_factor = 0.9

    # New data required for the function
    worker_hours_per_product = 2.0  # Assumption
    hourly_wage = 20.0  # Assumption
    hourly_wage_overtime = 35.0  # Assumption
    hiring_cost = 10.0  # Assumption
    layoff_cost = 5.0  # Assumption
    initial_workers = 10  # Assumption

    # Create the problem
    problem = LpProblem("Advanced_Supply_Chain_Optimization", LpMaximize)

    # Index ranges for products, workstations, and periods
    products = range(products_total)
    workstations = range(workstations_total)
    periods = range(time_horizon)

    # Decision Variables
    Produced = [[LpVariable(f"Produced_{i}_{t}", lowBound=0, cat='Continuous') for t in periods] for i in products]
    Sale = [[LpVariable(f"Sale_{i}_{t}", lowBound=0, cat='Continuous') for t in periods] for i in products]
    Stock = [[LpVariable(f"Stock_{i}_{t}", lowBound=0, cat='Continuous') for t in periods] for i in products]
    Workforce = [LpVariable(f"Workforce_{t}", lowBound=0) for t in periods]
    Hires = [LpVariable(f"Hires_{t}", lowBound=0) for t in periods]
    Firings = [LpVariable(f"Firings_{t}", lowBound=0) for t in periods]
    Overtime = [LpVariable(f"Overtime_{t}", lowBound=0) for t in periods]

    # Objective Function
    profit_term = lpSum(profit[i] * Sale[i][t] for i in products for t in periods)
    holding_cost_term = lpSum(holding_costs[i] * Stock[i][t] for i in products for t in periods)
    worker_cost_term = lpSum(hourly_wage * Workforce[t] for t in periods)
    overtime_cost_term = lpSum(hourly_wage_overtime * Overtime[t] for t in periods)
    hires_cost_term = lpSum(hiring_cost * Hires[t] for t in periods)
    firings_cost_term = lpSum(layoff_cost * Firings[t] for t in periods)
    problem += profit_term - holding_cost_term - worker_cost_term - overtime_cost_term - hires_cost_term - firings_cost_term

    # Constraints
    for i in products:
        for t in periods:
            # Sales constraints
            problem += Sale[i][t] >= min_sales[i][t], f"Min_Sales_{i}_{t}"
            problem += Sale[i][t] <= max_demand[i][t], f"Max_Demand_{i}_{t}"
            # Inventory balance constraint
            if t == 0:
                problem += Stock[i][t] == initial_inventory[i] + Produced[i][t] - Sale[i][t], f"Stock_Balance_{i}_{t}"
            else:
                problem += Stock[i][t] == Stock[i][t-1] + Produced[i][t] - Sale[i][t], f"Stock_Balance_{i}_{t}"

    for j in workstations:
        for t in periods:
            # Adjusted capacity constraint
            problem += lpSum(production_time[i][j] * Produced[i][t] / yield_loss[i][j] for i in products) <= \
                       capacity[j][t] * capacity_reduction_factor, f"Adjusted_Capacity_{j}_{t}"

    for t in periods:
        # Workforce constraints
        problem += lpSum(Produced[i][t] for i in products) * worker_hours_per_product <= Workforce[t] + Overtime[t], f"Workforce_Requirement_{t}"
        if t == 0:
            problem += Workforce[t] == initial_workers + Hires[t] - Firings[t], f"Workforce_Balance_{t}"
        else:
            problem += Workforce[t] == Workforce[t-1] + Hires[t] - Firings[t], f"Workforce_Balance_{t}"

    # Solve the problem
    problem.solve()

    # Output the results
    print_result = lambda s, v: [f"{s}: {[[v[i][t].varValue for t in periods] for i in products]}" if isinstance(v[0], list) else f"{s}: {[v[t].varValue for t in periods]}" for v in [v]]

    # Extract the optimization results
    results = {
        "Produced": [[Produced[i][t].varValue for t in periods] for i in products],
        "Sale": [[Sale[i][t].varValue for t in periods] for i in products],
        "Stock": [[Stock[i][t].varValue for t in periods] for i in products],
        "Workforce": [Workforce[t].varValue for t in periods],
        "Hires": [Hires[t].varValue for t in periods],
        "Firings": [Firings[t].varValue for t in periods],
        "Overtime": [Overtime[t].varValue for t in periods],
        "Profit": pulp.value(problem.objective)
    }

    for key, value in results.items():
        print(f"{key}: {value}")

    return results

# Call the function to optimize production
optimize_production()
```"""

------------------------------------------------------------------------------------------------------------------------------------------

LP Model Simulation:

# Update Latest Version and Shorter Return Feedback
import numpy as np
import simpy
import random

def run_extended_simulation(produced_Prev, sale_Prev, overtime_Prev, workers_Prev, hired_Prev, fired_Prev, initial_inventory, seed=42):
    random.seed(seed)
    np.random.seed(seed)

    # Specific profits and holding costs for each product
    profit_per_unit = [132.0, 813.0, 225.0, 131.0]
    holding_cost_per_unit = [13.0, 18.0, 15.0, 13.0]

    worker_hours_per_product = 2.0
    hourly_wage = 20.0
    hourly_wage_overtime = 30.0
    hiring_cost = 100.0
    layoff_cost = 50.0
    initial_workers = workers_Prev[0]

    resource_requirement = [
        [0.8, 0.5, 1.0, 4.0],
        [0.5, 1.3, 3.0, 1.0],
        [2.0, 1.0, 2.0, 4.0],
        [2.0, 6.0, 4.0, 2.0],
    ]
    resource_capacity = [
        [7071.0, 29208.0, 11107.0, 4708.0, 2450.0, 2900.0],
        [4425.0, 22041.0, 3861.0, 2101.0, 14025.0, 2900.0],
        [70103.0, 1103.0, 20517.0, 4051.0, 9025.0, 1403.0],
        [200.0, 31601.0, 4709.0, 25019.0, 14500.0, 2003.0],
    ]

    Workstation_capacities = [250, 175, 300]
    product_workflows = [
        [1, 2],  # Product 0
        [0, 2],  # Product 1
        [1],     # Product 2
        [1, 2],  # Product 3
    ]

    env = simpy.Environment()

    class Workstation:
        def __init__(self, env, capacity, id):
            self.env = env
            self.capacity = capacity
            self.id = id
            self.queue = simpy.Resource(env, capacity=capacity)

    class MultiProductFactory:
        def __init__(self, env, workstations):
            self.env = env
            self.inventory = list(initial_inventory)
            self.total_profits = 0.0
            self.period_results = []
            self.workstations = workstations
            self.workforce = initial_workers
            self.resources = [list(capacity) for capacity in resource_capacity]  # Initialize resource capacities

        def process_at_workstation(self, workstation, produced, product_id):
            with workstation.queue.request() as request:
                yield request
                processing_time = produced / workstation.capacity
                yield self.env.timeout(processing_time)

        def run_factory(self):
            for period in range(len(produced_Prev[0])):
                period_data = {'Period': period, 'Products': []}
                total_produced = 0
                for product_id in range(len(self.inventory)):
                    try:
                        produced = produced_Prev[product_id][period]
                    except IndexError:
                        produced = 0

                    # Resource requirements and checking capacities
                    for resource_id in range(len(resource_requirement)):
                        required_resource = produced * resource_requirement[resource_id][product_id]
                        if required_resource > self.resources[resource_id][period]:
                            produced = self.resources[resource_id][period] / resource_requirement[resource_id][product_id]
                            self.resources[resource_id][period] = 0
                        else:
                            self.resources[resource_id][period] -= required_resource

                    self.inventory[product_id] += produced
                    total_produced += produced

                    for workstation_id in product_workflows[product_id]:
                        workstation = self.workstations[workstation_id]
                        if produced > 0:
                            yield self.env.process(self.process_at_workstation(workstation, produced, product_id))

                    fluctuation = random.uniform(-0.1, 0.1)
                    try:
                        actual_demand = sale_Prev[product_id][period] * (1 + fluctuation)
                    except IndexError:
                        actual_demand = 0
                    sold = min(self.inventory[product_id], actual_demand)
                    missed_sales = max(actual_demand - sold, 0)

                    revenue = sold * profit_per_unit[product_id]
                    holding_costs = self.inventory[product_id] * holding_cost_per_unit[product_id]
                    period_profit = revenue - holding_costs
                    self.total_profits += period_profit

                    self.inventory[product_id] = max(self.inventory[product_id] - sold, 0)

                    product_data = {
                        'Product ID': product_id,
                        'Produced': produced,
                        'Sold': sold,
                        'Missed Sales': missed_sales,
                        'Ending Inventory': self.inventory[product_id],
                        'Period Profit': period_profit
                    }
                    period_data['Products'].append(product_data)

                total_required_worker_hours = total_produced * worker_hours_per_product
                overtime_hours = max(total_required_worker_hours - self.workforce, 0)
                regular_hours = min(total_required_worker_hours, self.workforce)
                hiring_needed = max(total_required_worker_hours - (self.workforce + overtime_hours), 0)
                layoffs_needed = max(self.workforce - total_required_worker_hours, 0)

                self.workforce += hiring_needed - layoffs_needed

                period_data.update({
                    'Overtime Hours': overtime_hours,
                    'Regular Hours': regular_hours,
                    'Hired': hiring_needed,
                    'Fired': layoffs_needed,
                    'Workforce': self.workforce
                })

                overtime_cost = overtime_hours * hourly_wage_overtime
                regular_cost = regular_hours * hourly_wage
                hiring_cost_total = hiring_needed * hiring_cost
                layoff_cost_total = layoffs_needed * layoff_cost

                period_profit -= (overtime_cost + regular_cost + hiring_cost_total + layoff_cost_total)
                self.total_profits += period_profit

                self.period_results.append(period_data)
                yield env.timeout(1)

    produced_Prev = np.array(produced_Prev)
    sale_Prev = np.array(sale_Prev)

    workstations = [Workstation(env, capacity, id) for id, capacity in enumerate(Workstation_capacities)]
    factory = MultiProductFactory(env, workstations)
    env.process(factory.run_factory())
    env.run()

    return factory.period_results, f"\nTotal Profits across all products and periods: {factory.total_profits:.2f}"






------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------



LP Optimization Model

import pulp

# Input data
time_horizon = 6
products_total = 4
workstations_total = 4
ressources_total = 4

min_sales = [
    [71.0, 28.0, 110.0, 78.0, 45.0, 90.0],
    [5.0, 21.0, 3.0, 211.0, 55.0, 9.0],
    [23.0, 105.0, 27.0, 75.0, 95.0, 43.0],
    [20.0, 36.0, 9.0, 29.0, 30.0, 20.0],
]
max_demand = [
    [371.0, 228.0, 111.0, 478.0, 245.0, 190.0],
    [425.0, 221.0, 381.0, 211.0, 155.0, 90.0],
    [203.0, 415.0, 217.0, 475.0, 95.0, 143.0],
    [200.0, 316.0, 479.0, 259.0, 130.0, 203.0],
]
capacity = [
    [3071.0, 228.0, 1011.0, 4708.0, 2405.0, 1000.0],
    [4205.0, 2201.0, 381.0, 2101.0, 105.0, 900.0],
    [203.0, 405.0, 2107.0, 4075.0, 905.0, 1403.0],
    [200.0, 3016.0, 4709.0, 2059.0, 130.0, 2003.0],
]
production_time = [
    [1.0, 2.0, 1.0, 4.0, 2.0, 9.0],
    [2.0, 1.0, 3.0, 1.0, 5.0, 9.0],
    [2.0, 1.0, 2.0, 4.0, 5.0, 1.0],
    [2.0, 6.0, 4.0, 2.0, 1.0, 2.0],
]
resource_requirement = [
    [300.8, 30.5, 1.0, 3.0],
    [5.5, 14.3, 33.0, 10.0],
    [50.0, 14.0, 2.0, 40.0],
    [2.0, 6.0, 40.0, 1.0],
]
resource_capacity = [
    [100.0, 8345.0, 1417.0, 407.0, 20.0, 290.0],
    [25.0, 41.0, 338.0, 210.0, 405.0, 2090.0],
    [7103.0, 30.0, 2007.0, 430.0, 90.0, 140.0],
    [200.0, 3001.0, 470.0, 2109.0, 140.0, 203.0],
]
initial_inventory = [41.0, 58.0, 31.0, 38.0]
back_orders_penalty = [5, 6, 7, 2]
profit_per_unit = [132.0, 83.0, 225.0, 131.0]
holding_cost_per_unit = [3.0, 8.0, 5.0, 1.0]

worker_hours_per_product = 2.0
hourly_wage = 20.0
hourly_wage_overtime = 30.0
hiring_cost = 10.0
layoff_cost = 50.0
initial_workers = [50, 60, 70, 80]

def optimization_model(time_horizon, products_total, workstations_total, max_demand, min_sales,
                       production_time, capacity, profit_per_unit, holding_cost_per_unit, initial_inventory,
                       resource_requirement, resource_capacity, back_orders_penalty,
                       worker_hours_per_product, hourly_wage, hourly_wage_overtime, hiring_cost, layoff_cost, initial_workers):

    # Create the problem
    problem = pulp.LpProblem("Advanced_Supply_Chain_Optimization", pulp.LpMaximize)

    # Decision Variables
    Amount_produced = [[pulp.LpVariable(f"Produced_{i}_{t}", lowBound=0, cat='Continuous') for t in range(time_horizon)] for i in range(products_total)]
    Amount_sold = [[pulp.LpVariable(f"Sale_{i}_{t}", lowBound=0, cat='Continuous') for t in range(time_horizon)] for i in range(products_total)]
    Inventory = [[pulp.LpVariable(f"Stock_{i}_{t}", lowBound=0, cat='Continuous') for t in range(time_horizon)] for i in range(products_total)]
    Workforce = [pulp.LpVariable(f"Workforce_{t}", lowBound=0, cat='Continuous') for t in range(time_horizon)]
    Hires = [pulp.LpVariable(f"Hires_{t}", lowBound=0, cat='Continuous') for t in range(time_horizon)]
    Firings = [pulp.LpVariable(f"Firings_{t}", lowBound=0, cat='Continuous') for t in range(time_horizon)]
    Overtime = [pulp.LpVariable(f"Overtime_{t}", lowBound=0, cat='Continuous') for t in range(time_horizon)]

    # Objective Function
    profit_term = pulp.lpSum(profit_per_unit[i] * Amount_sold[i][t] for i in range(products_total) for t in range(time_horizon))
    holding_cost_term = pulp.lpSum(holding_cost_per_unit[i] * Inventory[i][t] for i in range(products_total) for t in range(time_horizon))
    wage_cost_term = pulp.lpSum(hourly_wage * Workforce[t] for t in range(time_horizon))
    overtime_cost_term = pulp.lpSum(hourly_wage_overtime * Overtime[t] for t in range(time_horizon))
    hiring_cost_term = pulp.lpSum(hiring_cost * Hires[t] for t in range(time_horizon))
    layoff_cost_term = pulp.lpSum(layoff_cost * Firings[t] for t in range(time_horizon))
    problem += profit_term - holding_cost_term - wage_cost_term - overtime_cost_term - hiring_cost_term - layoff_cost_term

    # Constraints
    for i in range(products_total):
        for t in range(time_horizon):
            problem += Amount_sold[i][t] >= min_sales[i][t], f"Min_Sales_{i}_{t}"
            problem += Amount_sold[i][t] <= max_demand[i][t], f"Max_Demand_{i}_{t}"
            if t == 0:
                problem += Inventory[i][t] == initial_inventory[i] + Amount_produced[i][t] - Amount_sold[i][t], f"Inventory_Balance_{i}_{t}"
            else:
                problem += Inventory[i][t] == Inventory[i][t-1] + Amount_produced[i][t] - Amount_sold[i][t], f"Inventory_Balance_{i}_{t}"

    for j in range(workstations_total):
        for t in range(time_horizon):
            problem += pulp.lpSum(production_time[i][j] * Amount_produced[i][t] for i in range(products_total)) <= capacity[j][t] + Overtime[t], f"Capacity_{j}_{t}"

    for t in range(time_horizon):
        if t == 0:
            problem += Workforce[t] == initial_workers[0] + Hires[t] - Firings[t], f"Workforce_Balance_{t}"
        else:
            problem += Workforce[t] == Workforce[t-1] + Hires[t] - Firings[t], f"Workforce_Balance_{t}"
        problem += pulp.lpSum(worker_hours_per_product * Amount_produced[i][t] for i in range(products_total)) <= Workforce[t] + Overtime[t], f"Work_Ontime_Constraint_{t}"

    # Solve the problem
    problem.solve()

    # Output the results
    decision_variables = {
        "Produced": [[Amount_produced[i][t].varValue for t in range(time_horizon)] for i in range(products_total)],
        "Sale": [[Amount_sold[i][t].varValue for t in range(time_horizon)] for i in range(products_total)],
        "Stock": [[Inventory[i][t].varValue for t in range(time_horizon)] for i in range(products_total)],
        "Workforce": [Workforce[t].varValue for t in range(time_horizon)],
        "Hires": [Hires[t].varValue for t in range(time_horizon)],
        "Firings": [Firings[t].varValue for t in range(time_horizon)],
        "Overtime": [Overtime[t].varValue for t in range(time_horizon)]
    }
    profit = pulp.value(problem.objective)

    for key, value in decision_variables.items():
        print(f'{key}: {value}')

    print(f'Profit Earned: {profit}')

    return decision_variables, profit

optimization_model(time_horizon, products_total, workstations_total, max_demand, min_sales,
                   production_time, capacity, profit_per_unit, holding_cost_per_unit, initial_inventory,
                   resource_requirement, resource_capacity, back_orders_penalty,
                   worker_hours_per_product, hourly_wage, hourly_wage_overtime, hiring_cost, layoff_cost, initial_workers)
```'''


--------------------------------------------------------------------------------------------------------------------------------------

MINLP Simulation Model


import numpy as np
import simpy
import random

def run_extended_simulation(produced_Prev, sale_Prev, overtime_Prev, workers_Prev, hired_Prev, fired_Prev, initial_inventory, seed=42):
    random.seed(seed)
    np.random.seed(seed)

    num_periods = 6
    back_orders_penalty = [5, 6, 7, 2]

    # Specific profits and holding costs for each product
    profit_per_unit = [132.0, 83.0, 225.0, 131.0]
    holding_cost_per_unit = [3.0, 8.0, 5.0, 1.0]

    worker_hours_per_product = 2.0
    #hourly_wage = 20.0
    hourly_wage = 20.0
    hourly_wage_overtime = 30.0
    hiring_cost = 10.0
    layoff_cost = 50.0

    resource_requirement = [
        [300.8, 30.5, 1.0, 3.0],
        [5.5, 14.3, 33.0, 10.0],
        [50.0, 14.0, 2.0, 40.0],
        [2.0, 6.0, 40.0, 1.0],
    ]

    resource_capacity = [
        [100.0, 8345.0, 1417.0, 407.0, 20.0, 290.0],
        [25.0, 41.0, 338.0, 210.0, 405.0, 2090.0],
        [7103.0, 30.0, 2007.0, 430.0, 90.0, 140.0],
        [200.0, 3001.0, 470.0, 2109.0, 140.0, 203.0],
    ]

    Workstation_capacities = [25, 75, 30]

    product_workflows = [
        [1, 2],  # Product 0
        [0, 2],  # Product 1
        [1],     # Product 2
        [1, 2],  # Product 3
    ]

    env = simpy.Environment()

    class Workstation:
        def __init__(self, env, capacity, id):
            self.env = env
            self.capacity = capacity
            self.id = id
            self.queue = simpy.Resource(env, capacity=capacity)
            self.working = True

        def fail(self, duration):
            self.working = False
            yield self.env.timeout(duration)
            self.working = True

        def process(self, produced):
            if self.working:
                with self.queue.request() as request:
                    yield request
                    processing_time = produced / self.capacity
                    yield self.env.timeout(processing_time)
            else:
                yield self.env.timeout(1)  # Wait for 1 unit of time before trying again

    class WorkerShift:
        def __init__(self, env, shifts):
            self.env = env
            self.shifts = shifts
            self.current_shift = 0
            self.current_workers = shifts[0]['workers']

        def change_shift(self):
            while True:
                yield self.env.timeout(8)  # Change shift every 8 hours
                self.current_shift = (self.current_shift + 1) % len(self.shifts)
                self.current_workers = self.shifts[self.current_shift]['workers']
                print(f"Shift change at time {self.env.now:.2f}. Current workers: {self.current_workers}")

    class MultiProductFactory:
        def __init__(self, env, workstations, worker_shift):
            self.env = env
            self.inventory = list(initial_inventory)
            self.total_profits = 0.0
            self.period_results = []
            self.workstations = workstations
            self.worker_shift = worker_shift
            self.resources = [list(capacity) for capacity in resource_capacity]  # Initialize resource capacities

        def process_at_workstation(self, workstation, produced, product_id):
            with workstation.queue.request() as request:
                yield request
                processing_time = produced / workstation.capacity
                yield self.env.timeout(processing_time)

        def run_factory(self):
            for period in range(num_periods):
                print(f"\n--- Period {period + 1} ---")
                period_data = {'Period': period, 'Products': []}
                total_produced = 0
                total_sales = 0

                # Simulate workstation outages randomly
                for ws in self.workstations:
                    if ws.id == 2:  # Example: Specific workstation id for potential outage
                        if np.random.poisson(1/5) >= 1:  # Poisson distribution to simulate outages
                            downtime_duration = 2  # Downtime duration in time units
                            print(f"Workstation {ws.id} starting downtime at time {self.env.now} for {downtime_duration} periods.")
                            yield self.env.process(ws.fail(downtime_duration))
                            print(f"Workstation {ws.id} ending downtime at time {self.env.now}.")

                for product_id in range(len(self.inventory)):
                    produced = produced_Prev[product_id][period]

                    # Resource requirements and checking capacities
                    for resource_id in range(len(resource_requirement)):
                        required_resource = produced * resource_requirement[resource_id][product_id]
                        if required_resource > self.resources[resource_id][period]:
                            produced = self.resources[resource_id][period] / resource_requirement[resource_id][product_id]
                            self.resources[resource_id][period] = 0
                        else:
                            self.resources[resource_id][period] -= required_resource

                    self.inventory[product_id] += produced
                    total_produced += produced

                    for workstation_id in product_workflows[product_id]:
                        workstation = self.workstations[workstation_id]
                        if produced > 0:
                            yield self.env.process(self.process_at_workstation(workstation, produced, product_id))

                    fluctuation = random.uniform(-0.1, 0.1)
                    actual_demand = sale_Prev[product_id][period] * (1 + fluctuation)
                    sold = min(self.inventory[product_id], actual_demand)
                    missed_sales = max(actual_demand - sold, 0)

                    revenue = sold * profit_per_unit[product_id]
                    holding_costs = self.inventory[product_id] * holding_cost_per_unit[product_id]
                    period_profit = revenue - holding_costs
                    self.total_profits += period_profit

                    self.inventory[product_id] = max(self.inventory[product_id] - sold, 0)

                    product_data = {
                        'Product ID': product_id,
                        'Produced': produced,
                        'Sold': sold,
                        'Missed Sales': missed_sales,
                        'Ending Inventory': self.inventory[product_id],
                        'Period Profit': period_profit
                    }
                    period_data['Products'].append(product_data)

                total_required_worker_hours = total_produced * worker_hours_per_product
                overtime_hours = max(total_required_worker_hours - self.worker_shift.current_workers * 8, 0)
                regular_hours = min(total_required_worker_hours, self.worker_shift.current_workers * 8)
                hiring_needed = max((total_required_worker_hours - regular_hours - overtime_hours) / 8, 0)
                layoffs_needed = max((self.worker_shift.current_workers * 8 - total_required_worker_hours) / 8, 0)

                self.worker_shift.current_workers += hiring_needed - layoffs_needed

                # Calculate arbeitsauslastung
                available_worker_hours = self.worker_shift.current_workers * 8  # Assuming each worker works for 8 hours per shift
                arbeitsauslastung = total_required_worker_hours / available_worker_hours if available_worker_hours > 0 else 0

                overtime_cost = overtime_hours * hourly_wage_overtime
                regular_cost = regular_hours * hourly_wage
                hiring_cost_total = hiring_needed * hiring_cost
                layoff_cost_total = layoffs_needed * layoff_cost

                period_profit -= (overtime_cost + regular_cost + hiring_cost_total + layoff_cost_total)
                self.total_profits += period_profit

                period_data.update({
                    'Overtime Hours': overtime_hours,
                    'Regular Hours': regular_hours,
                    'Hired': hiring_needed,
                    'Fired': layoffs_needed,
                    'Workforce': self.worker_shift.current_workers,
                    'Workforce Utilization': arbeitsauslastung
                })

                self.period_results.append(period_data)
                yield self.env.timeout(1)

    produced_Prev = np.array(produced_Prev)
    sale_Prev = np.array(sale_Prev)

    workstations = [Workstation(env, capacity, id) for id, capacity in enumerate(Workstation_capacities)]
    worker_shift = WorkerShift(env, shifts=[
        {'start': 0, 'end': 8, 'workers': 223},
        {'start': 8, 'end': 16, 'workers': 230},
        {'start': 16, 'end': 24, 'workers': 55}
    ])
    factory = MultiProductFactory(env, workstations, worker_shift)

    env.process(worker_shift.change_shift())
    env.process(factory.run_factory())
    env.run(until=num_periods * 24)  # Ensure the environment runs through all periods

    return factory.period_results, f"\nTotal Profits across all products and periods: {factory.total_profits:.2f}"






